---
title: "EEPROM Glitch"
permalink: /docs/eeprom-glitch/
excerpt: "Issues when using EEPROMs to produce control signals"
---

EEPROMs are a straightforward and convenient way to produce the system control signals. Microcode is stored in EEPROMs, with the Step Counter and Instruction Register values driving the EEPROM address lines and the EEPROM data outputs providing the system control signals.  However, there is an important property of EEPROM operation that causes problems.

## The EEPROM "glitch"

When the address lines on an EEPROM are changed, there is a settling period before the outputs show the data value at the associated address.  During this time, the outputs are still being driven (they are not floating), but it is not known if they will be in a high state or a low state.  For example, if the bytes at address 4 and address 5 both contain a zero bit for pin D0, the pin could still briefly produce a one value when the address is changed from 4 to 5.  Although this is a normal property of memory chips, it causes issues because of the way the chips are used in TTL computer builds.  The problem has been referred to as EEPROM glitching.

Unpredictable signals from the Microcode EEPROM can cause spurious signals to be generated.  For example, if multiple register read lines are active at once, it will cause brief bus contention.  If the signals are combined with other logic to generate clocks for other chips, then spurious clock pulses could be generated that cause registers or RAM to load at random times.

## Instruction cycle

The [WaveDrom](https://wavedrom.com) timing diagram below shows the first four clock cycles for an instruction in the SAP-1 computer.  The Ring Counter value changes on every falling clock edge and the Instruction Register value changes on the rising edge of instruction step 1 (_T1_).  Both of these events change the address inputs to the EEPROMs and cause a brief period of uncertainty for all of the control outputs.  In addition, the SAP-1 also drives address lines with the outputs of the Flags Register, so this causes uncertainty on any rising CLK edge of a microinstruction step that modifies the flags.

![Instruction cycle timing with EEPROM glitch](../../assets/images/timing-glitch-first-4.png "SAP-1 instruction cycle timing showing EEPROM glitch")

For the SAP-1 design, these output glitches are not usually a problem. Many of the instruction steps in the SAP-1 designs move values from one register to another.  The SAP-1 uses 74LS173 registers to read and store values from the bus and 74LS245 tranceivers to put values on the bus. For example, the _T0_ step of every instruction moves the contents of the Program Counter (PC) to the Memory Address Register (MAR).   The timing diagram below shows the behavior of the Program Counter Out (CO) and MAR In (MI) lines.

![Move PC to MAR timing](../../assets/images/timing-glitch-pc-to-mar.png "cycle timing to move PC to MAR")

The following steps take place during the first instruction step:

* At marker 1, the Ring Counter is set to zero on the falling edge of CLK
* The Control EEPROM step address is set to the _T0_ instruction cycle
* The CO and MI signals are asserted after briefly being in an unknown state while the EEPROM settles
* The CO signal places the contents of the PC on the bus
* At marker 3, the rising CLK edge, along with the MI signal, causes the PC value on the bus to be loaded into the MAR

The glitching of the MI signal does not cause any problems because the 74LS173 registers only load new values when the Load Enable signal is asserted and the clock is at a rising edge.  The Load Enable signals are always in a known state at the rising CLK edge.

## Issues when generating clock signals

Unlike the 74LS173 registers, some chips do not have two independent lines for Load Enable and CLK.  Instead, a single pin is pulsed and the chip loads when a clock pulse edge is detected.  In the SAP-Plus design, the static RAM and Stack Pointer both need clocked control signals. For these chips, a clock signal is generated by ANDing a control signal with the system clock.  This produces a pulse whenever the signal is asserted and the CLK is high.  

The timing diagram below shows a control clock pulse being generated in instruction cycle T3.  The control signal is asserted at marker 13 and the clock pulse begins at marker 15.  

![Instruction cycle with control clock](../../assets/images/timing-glitch-control-clock.png "cycle timing with control clock")

Note that the signal uncertainty at marker 13 does not cause a problem because the clock signal is still low at that point, so the state of the control signal does not matter.  Similarly, none of the other EEPROM glitching on the falling edge of the clock causes an issue.

The EEPROM glitch behavior does cause a problem in _T1_ instruction step at marker 7. This is the point where the Instruction Register is loaded, causing the EEPROM address to change on the positive edge of the system clock.  With the CLK signal high, any glitch on the control line will produce one or more brief control clock pulses that could cause their register to inadvertantly load a value from the bus.  

In the SAP-1 design, the flag outputs also drive microcode EEPROM address lines to do conditional jumps, so the glitch would also be a problem after the rising edge clock of any microinstruction step that loads new flag values.

## Mitigating the glitch with analog solutions

Several analog solutions have been proposed to mitigate the EEPROM glitching in TTL computer builds.  One approach is to add low-pass filters to the control lines to eliminate the high frequency spikes that occur during the EEPROM address switching.

Another solution is to use pull-up or pull-down resistors on the control lines. Because the lines are not floating during the glitch period, this does not actually pull the signals to a desired state.  Instead, it just flattens the rise or fall time of the signal a bit.  If the period of the glitch is short enough, this may cause the glitch pulse to never cross a logic threshold that would make other hardware act on it.

## SAP-Plus design to avoid the glitch

SAP-Plus solves the EEPROM glitch in the digital domain by making changes to the design of the flags and the Instruction Register.  

### Buffered Flags

The Zero and Carry flag bits from the Flags register are not directly connected to the Microcode EEPROM address lines. Instead, the output of the Flags Register is connected to the upper two inputs of the Instruction Register.  The lower six bits of the IR are connected to the bus.  When the Write IR signal is asserted, the IR is loaded with a six bit opcode and two flag bits.  Because the flags are not directly wired to the EEPROM address lines, changing flag values does not cause any glitches.

### Double Buffered Instruction Register

The Instruction Register uses a double-buffered design to move the address line changes to the falling edge of the clock pulse.  The IR is loaded as usual on the rising edge of the clock in _T1_.  The outputs of IR are connected to the inputs of a second instruction register which is loaded on every falling clock pulse.  The outputs of this IR2 register are used to drive the address lines of the EEPROM.  

The result is that the address lines driven by the IR now change on the falling edge of instruction cycle _T1_, at the same time as the address lines driven by the Step Counter.

With the buffered flags and buffered IR, the outputs of the microcode EEPROMs are always stable when the clock is high, so they can safely be used with rising clock edges or ANDed with the clock signal.

### Multiplexed Chip Selects

Rather than driving the register read and write select lines directly, outputs from the Microcode ROM are fed into the inputs of 74LS138 3-to-8 multiplexers.  This reduces the number of ROM outputs and control bus signals needed, because 4 write signals from the ROM can select up to 15 write registers and 3 read signals from the ROM can select up to 7 read registers.  

The use of the multiplexers ensures that only one read select will be active at any time, so there is no momentaty bus contention while the ROM outputs are settling.
